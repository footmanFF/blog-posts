---
layout: post
title: Java类加载探究
date: 2018-02-09
tags: java,class loading
---

### class loading 理解

编译型语言的连接和Java的连接

> C/C++等纯编译语言从源码到最终执行一般要经历：编译、连接和运行三个阶段，连接是在编译期间完成，而java在编译期间仅仅是将源码编译为Java虚拟机可以识别的字节码Class类文件，Java虚拟机对中Class类文件的加载、连接都在运行时执行
>
> http://www.cnblogs.com/hnlshzx/p/3533264.html

编译型语言有连接，Java 也有连接，那么所谓的连接到底是干什么的。C 的连接：

> 把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中。这就叫做连接（linking）。这种通过拷贝，将外部函数库添加到可执行文件的方式，叫做静态连接（static linking），后文会提到还有动态连接
>
> http://www.ruanyifeng.com/blog/2014/11/compiler.html

看起来就是所谓连接，连接的是将有相互调用关系的代码（函数）对接到一起，让他们组织成一个可执行的整体（他们有调用关系，本来就该在一起）。那么 Java 的连接有是啥（Linking）？

<!-- more -->

#### 加载

解析类的二进制字节流，加载进内存并形成运行时数据结构，生成一个 Class 对象。如果单单是一次 class loading 的加载阶段，并且加载阶段还没有完成，此时 Class 对象可能是不完整（至少可能不是完全解析的）。一些 JVM 实现（比如有 HotSpot）是按需解析符号引用的，Class 内的一些符号引用直到在最终使用的时候才会去解析。详细内容见下面的解析阶段。

#### 验证

安全，错误校验 ...

#### 准备

为类中的变量分配内存（静态变量）。内存内一定会有个初始值（0/1），所以这个阶段的变量都会有一个初始值，这个初始值是零值。但有一种例外，被 final 修饰的静态变量，这个阶段就会直接给赋上申明的值。

名为准备，准备的其实是内存，类变量的内存。final 修饰时内存的默认值为指定的，不然就是零值。

#### 解析

这个阶段将符号引用替换为直接引用。

> 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。

> 直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。

符号引用是如何转化成直接引用的？

> https://www.zhihu.com/question/30300585

> 虚拟机实现可以根据需要来判断：到底是在类被加载器加载时就对符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

> 不同的JVM实现可能选择不同的解析策略。一种做法是在链接的时候，就递归的把所有依赖的形式引用都进行解析。而另外的做法则可能是只在一个形式引用真正需要的时候才进行解析。也就是说如果一个Java类只是被引用了，但是并没有被真正用到，那么这个类有可能就不会被解析。

#### 初始化

估计是执行 static 块代码，赋值 static 变量（不带 final），

#### 使用

#### 卸载

Java 源文件是编译成字节码的，称为 class。class （来自文件或者字节流），class 是一个类的元信息（模板）。JVM 实例化一个类是需要这个元信息的。

### 问题记录

- 类初始化时机，什么时候会触发一个类的初始化
- 符号引用是啥？？符号引用这个东西好像是有印象很重要
- 平时的编译错误一般都是自己写的类会报编译错误，比如 import 不存在的类。引用的其他 jar 包如果也 import 不存在的类，应该是不会在编译的时候报错的，而是在运行的时候报 class not found。那么问题是：为什么编译的时候，jar 包内的类引用错误不会报编译错误？

### 引用

http://www.infoq.com/cn/articles/cf-Java-class-loader